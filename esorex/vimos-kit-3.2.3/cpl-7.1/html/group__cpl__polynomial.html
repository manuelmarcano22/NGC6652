<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Common Pipeline Library Reference Manual: Polynomials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cpl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Common Pipeline Library Reference Manual
   &#160;<span id="projectnumber">7.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Polynomials</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7d2f8e83cf135808812d4408a0b80225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">cpl_polynomial_add</a> (cpl_polynomial *self, const cpl_polynomial *first, const cpl_polynomial *second)</td></tr>
<tr class="memdesc:ga7d2f8e83cf135808812d4408a0b80225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two polynomials of the same dimension.  <a href="#ga7d2f8e83cf135808812d4408a0b80225">More...</a><br /></td></tr>
<tr class="separator:ga7d2f8e83cf135808812d4408a0b80225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ca2bc6c97bffa796f321af895bd4a20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga5ca2bc6c97bffa796f321af895bd4a20">cpl_polynomial_compare</a> (const cpl_polynomial *p1, const cpl_polynomial *p2, double tol)</td></tr>
<tr class="memdesc:ga5ca2bc6c97bffa796f321af895bd4a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the coefficients of two polynomials.  <a href="#ga5ca2bc6c97bffa796f321af895bd4a20">More...</a><br /></td></tr>
<tr class="separator:ga5ca2bc6c97bffa796f321af895bd4a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9242d9e26e39a675f5ca8ddc45f629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gafa9242d9e26e39a675f5ca8ddc45f629">cpl_polynomial_copy</a> (cpl_polynomial *out, const cpl_polynomial *in)</td></tr>
<tr class="memdesc:gafa9242d9e26e39a675f5ca8ddc45f629"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies contents of a polynomial into another one.  <a href="#gafa9242d9e26e39a675f5ca8ddc45f629">More...</a><br /></td></tr>
<tr class="separator:gafa9242d9e26e39a675f5ca8ddc45f629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad27580d5c9e514cdbcddbd0d4d038e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7">cpl_polynomial_delete</a> (cpl_polynomial *p)</td></tr>
<tr class="memdesc:gaad27580d5c9e514cdbcddbd0d4d038e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a cpl_polynomial.  <a href="#gaad27580d5c9e514cdbcddbd0d4d038e7">More...</a><br /></td></tr>
<tr class="separator:gaad27580d5c9e514cdbcddbd0d4d038e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efdebaaf27c73481a42622d45f02b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga2efdebaaf27c73481a42622d45f02b4a">cpl_polynomial_derivative</a> (cpl_polynomial *self, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> dim)</td></tr>
<tr class="memdesc:ga2efdebaaf27c73481a42622d45f02b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a first order partial derivative.  <a href="#ga2efdebaaf27c73481a42622d45f02b4a">More...</a><br /></td></tr>
<tr class="separator:ga2efdebaaf27c73481a42622d45f02b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063de2b8047d89e539358ad990eed3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga063de2b8047d89e539358ad990eed3f2">cpl_polynomial_dump</a> (const cpl_polynomial *p, FILE *stream)</td></tr>
<tr class="memdesc:ga063de2b8047d89e539358ad990eed3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a cpl_polynomial as ASCII to a stream.  <a href="#ga063de2b8047d89e539358ad990eed3f2">More...</a><br /></td></tr>
<tr class="separator:ga063de2b8047d89e539358ad990eed3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c3d942b1525bad657cd44ff2e0fbfb"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga62c3d942b1525bad657cd44ff2e0fbfb">cpl_polynomial_duplicate</a> (const cpl_polynomial *p)</td></tr>
<tr class="memdesc:ga62c3d942b1525bad657cd44ff2e0fbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function duplicates an existing polynomial.  <a href="#ga62c3d942b1525bad657cd44ff2e0fbfb">More...</a><br /></td></tr>
<tr class="separator:ga62c3d942b1525bad657cd44ff2e0fbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7022ca32043652bfbd767b197b83bf9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gad7022ca32043652bfbd767b197b83bf9">cpl_polynomial_eval</a> (const cpl_polynomial *p, const cpl_vector *x)</td></tr>
<tr class="memdesc:gad7022ca32043652bfbd767b197b83bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the polynomial at the given point.  <a href="#gad7022ca32043652bfbd767b197b83bf9">More...</a><br /></td></tr>
<tr class="separator:gad7022ca32043652bfbd767b197b83bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab002089746a121023e072d2f5d8b057d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d">cpl_polynomial_eval_1d</a> (const cpl_polynomial *self, double x, double *pd)</td></tr>
<tr class="memdesc:gab002089746a121023e072d2f5d8b057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a univariate (1D) polynomial using Horners rule.  <a href="#gab002089746a121023e072d2f5d8b057d">More...</a><br /></td></tr>
<tr class="separator:gab002089746a121023e072d2f5d8b057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a1224f9ecbc2a9984e27ba2a156c9b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gad5a1224f9ecbc2a9984e27ba2a156c9b">cpl_polynomial_eval_1d_diff</a> (const cpl_polynomial *self, double a, double b, double *ppa)</td></tr>
<tr class="memdesc:gad5a1224f9ecbc2a9984e27ba2a156c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate p(a) - p(b) using Horners rule.  <a href="#gad5a1224f9ecbc2a9984e27ba2a156c9b">More...</a><br /></td></tr>
<tr class="separator:gad5a1224f9ecbc2a9984e27ba2a156c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15adba8bfa7344bf4c87c35c77c7ae5a"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract</a> (const cpl_polynomial *self, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> dim, const cpl_polynomial *other)</td></tr>
<tr class="memdesc:ga15adba8bfa7344bf4c87c35c77c7ae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse one dimension of a multi-variate polynomial by composition.  <a href="#ga15adba8bfa7344bf4c87c35c77c7ae5a">More...</a><br /></td></tr>
<tr class="separator:ga15adba8bfa7344bf4c87c35c77c7ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4cdbbf2a50f568d9768cf793b53b187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">cpl_polynomial_fit</a> (cpl_polynomial *self, const cpl_matrix *samppos, const cpl_boolean *sampsym, const cpl_vector *fitvals, const cpl_vector *fitsigm, cpl_boolean dimdeg, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *mindeg, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *maxdeg)</td></tr>
<tr class="memdesc:gaa4cdbbf2a50f568d9768cf793b53b187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a polynomial to a set of samples in a least squares sense.  <a href="#gaa4cdbbf2a50f568d9768cf793b53b187">More...</a><br /></td></tr>
<tr class="separator:gaa4cdbbf2a50f568d9768cf793b53b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b13c82eb2b5ae32ba24fd4e3ea4b67"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gaf8b13c82eb2b5ae32ba24fd4e3ea4b67">cpl_polynomial_fit_1d_create</a> (const cpl_vector *x_pos, const cpl_vector *values, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> degree, double *mse)</td></tr>
<tr class="memdesc:gaf8b13c82eb2b5ae32ba24fd4e3ea4b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a 1D-polynomial to a 1D-signal in a least squares sense.  <a href="#gaf8b13c82eb2b5ae32ba24fd4e3ea4b67">More...</a><br /></td></tr>
<tr class="separator:gaf8b13c82eb2b5ae32ba24fd4e3ea4b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f64ecb14d48a4f5601e54a5914633ca"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga1f64ecb14d48a4f5601e54a5914633ca">cpl_polynomial_fit_2d_create</a> (cpl_bivector *xy_pos, cpl_vector *values, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> degree, double *mse)</td></tr>
<tr class="memdesc:ga1f64ecb14d48a4f5601e54a5914633ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a 2D-polynomial to a 2D-surface in a least squares sense.  <a href="#ga1f64ecb14d48a4f5601e54a5914633ca">More...</a><br /></td></tr>
<tr class="separator:ga1f64ecb14d48a4f5601e54a5914633ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8914a8d2c87faa2950f7a75c80e313fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga8914a8d2c87faa2950f7a75c80e313fb">cpl_polynomial_get_coeff</a> (const cpl_polynomial *in, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *pows)</td></tr>
<tr class="memdesc:ga8914a8d2c87faa2950f7a75c80e313fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a coefficient of the polynomial.  <a href="#ga8914a8d2c87faa2950f7a75c80e313fb">More...</a><br /></td></tr>
<tr class="separator:ga8914a8d2c87faa2950f7a75c80e313fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf283d2c2ad290406f5297c2cdf2bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gacbf283d2c2ad290406f5297c2cdf2bb0">cpl_polynomial_get_degree</a> (const cpl_polynomial *p)</td></tr>
<tr class="memdesc:gacbf283d2c2ad290406f5297c2cdf2bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The degree of the polynomial.  <a href="#gacbf283d2c2ad290406f5297c2cdf2bb0">More...</a><br /></td></tr>
<tr class="separator:gacbf283d2c2ad290406f5297c2cdf2bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4436f9900625ba6f19f189f5b0ee99d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga4436f9900625ba6f19f189f5b0ee99d2">cpl_polynomial_get_dimension</a> (const cpl_polynomial *p)</td></tr>
<tr class="memdesc:ga4436f9900625ba6f19f189f5b0ee99d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of the polynomial.  <a href="#ga4436f9900625ba6f19f189f5b0ee99d2">More...</a><br /></td></tr>
<tr class="separator:ga4436f9900625ba6f19f189f5b0ee99d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">cpl_polynomial_multiply_scalar</a> (cpl_polynomial *self, const cpl_polynomial *other, double factor)</td></tr>
<tr class="memdesc:gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a polynomial with a scalar.  <a href="#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">More...</a><br /></td></tr>
<tr class="separator:gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e95c460a991e29169ff1d079377f334"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga6e95c460a991e29169ff1d079377f334">cpl_polynomial_new</a> (<a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> dim)</td></tr>
<tr class="memdesc:ga6e95c460a991e29169ff1d079377f334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new cpl_polynomial.  <a href="#ga6e95c460a991e29169ff1d079377f334">More...</a><br /></td></tr>
<tr class="separator:ga6e95c460a991e29169ff1d079377f334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9bbab67ece20c05a3ad20f2c3fef203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gab9bbab67ece20c05a3ad20f2c3fef203">cpl_polynomial_set_coeff</a> (cpl_polynomial *in, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *pows, double c)</td></tr>
<tr class="memdesc:gab9bbab67ece20c05a3ad20f2c3fef203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a coefficient of the polynomial.  <a href="#gab9bbab67ece20c05a3ad20f2c3fef203">More...</a><br /></td></tr>
<tr class="separator:gab9bbab67ece20c05a3ad20f2c3fef203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad445a939e63d62bc91455b5ef7924559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d</a> (cpl_polynomial *p, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> i, double u)</td></tr>
<tr class="memdesc:gad445a939e63d62bc91455b5ef7924559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify p, p(x0, x1, ..., xi, ...) := (x0, x1, ..., xi+u, ...)  <a href="#gad445a939e63d62bc91455b5ef7924559">More...</a><br /></td></tr>
<tr class="separator:gad445a939e63d62bc91455b5ef7924559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a44da11383b2d44cd23cc0708611530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga9a44da11383b2d44cd23cc0708611530">cpl_polynomial_solve_1d</a> (const cpl_polynomial *p, double x0, double *px, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> mul)</td></tr>
<tr class="memdesc:ga9a44da11383b2d44cd23cc0708611530"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real solution to p(x) = 0 using Newton-Raphsons method.  <a href="#ga9a44da11383b2d44cd23cc0708611530">More...</a><br /></td></tr>
<tr class="separator:ga9a44da11383b2d44cd23cc0708611530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga457ef230f6dcc5ce6517386ea832aaa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">cpl_polynomial_subtract</a> (cpl_polynomial *self, const cpl_polynomial *first, const cpl_polynomial *second)</td></tr>
<tr class="memdesc:ga457ef230f6dcc5ce6517386ea832aaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two polynomials of the same dimension.  <a href="#ga457ef230f6dcc5ce6517386ea832aaa5">More...</a><br /></td></tr>
<tr class="separator:ga457ef230f6dcc5ce6517386ea832aaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09473199544ac51406f4952dad5b8665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga09473199544ac51406f4952dad5b8665">cpl_vector_fill_polynomial</a> (cpl_vector *v, const cpl_polynomial *p, double x0, double d)</td></tr>
<tr class="memdesc:ga09473199544ac51406f4952dad5b8665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 1D-polynomial on equidistant points using Horners rule.  <a href="#ga09473199544ac51406f4952dad5b8665">More...</a><br /></td></tr>
<tr class="separator:ga09473199544ac51406f4952dad5b8665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d23d4b42c4d98bb6e50e53e67350aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0">cpl_vector_fill_polynomial_fit_residual</a> (cpl_vector *self, const cpl_vector *fitvals, const cpl_vector *fitsigm, const cpl_polynomial *fit, const cpl_matrix *samppos, double *rechisq)</td></tr>
<tr class="memdesc:ga7d23d4b42c4d98bb6e50e53e67350aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the residual of a polynomial fit.  <a href="#ga7d23d4b42c4d98bb6e50e53e67350aa0">More...</a><br /></td></tr>
<tr class="separator:ga7d23d4b42c4d98bb6e50e53e67350aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module provides functions to handle uni- and multivariate polynomials.</p>
<p>Univariate (1D) polynomials use the Horner rule for evaluation, while multivariate polynomials are evaluated simply as the sum of each term.</p>
<p>This means that of the two polynomials </p><pre class="fragment">* P1(x) = p0 + p1.x + p4.x^2
* </pre><p> and </p><pre class="fragment">* P2(x,y) = p0 + p1.x + p2.y + p3.x.y + p4.x^2 + p5.y^2
* </pre><p> P1(x) may evaluate to more accurate results than P2(x,0), especially around the roots.</p>
<p>Note that a polynomial like P3(z) = p0 + p1.z + p2.z^2 + p3.z^3, z=x^4 is preferable to p4(x) = p0 + p1.x^4 + p2.x^8 + p3.x^12. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7d2f8e83cf135808812d4408a0b80225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_add </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two polynomials of the same dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to hold the result </td></tr>
    <tr><td class="paramname">first</td><td>The 1st polynomial to add </td></tr>
    <tr><td class="paramname">second</td><td>The 2nd polynomial to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant CPL error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>self may be passed also as first and/or second</dd></dl>
<p>Possible CPL error code set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the polynomials do not have identical dimensions</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if the dimension is not 1 (FIXME) </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__polynomial.html#ga8914a8d2c87faa2950f7a75c80e313fb">cpl_polynomial_get_coeff()</a>, <a class="el" href="group__cpl__polynomial.html#gacbf283d2c2ad290406f5297c2cdf2bb0">cpl_polynomial_get_degree()</a>, <a class="el" href="group__cpl__polynomial.html#ga4436f9900625ba6f19f189f5b0ee99d2">cpl_polynomial_get_dimension()</a>, and <a class="el" href="group__cpl__polynomial.html#gab9bbab67ece20c05a3ad20f2c3fef203">cpl_polynomial_set_coeff()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ca2bc6c97bffa796f321af895bd4a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_polynomial_compare </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the coefficients of two polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the 1st polynomial </td></tr>
    <tr><td class="paramname">p2</td><td>the 2nd polynomial </td></tr>
    <tr><td class="paramname">tol</td><td>The absolute (non-negative) tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when equal, positive when different, negative on error.</dd></dl>
<p>The two polynomials are considered equal iff they have identical dimensions and the absolute difference between their coefficients does not exceed the tolerance.</p>
<p>This means that the following pair of polynomials per definition are considered different: P1(x1,x2) = 3*x1 different from P2(x1) = 3*x1.</p>
<p>If all parameters are valid and p1 and p2 point to the same polynomial the functions returns 0.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if tol is negative </li>
</ul>

<p>References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

</div>
</div>
<a class="anchor" id="gafa9242d9e26e39a675f5ca8ddc45f629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_copy </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies contents of a polynomial into another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Pre-allocated output cpl_polynomial </td></tr>
    <tr><td class="paramname">in</td><td>Input cpl_polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a></dd></dl>
<p>in and out must point to different polynomials.</p>
<p>If out already contains coefficients, they are overwritten.</p>
<p>This is the only function that can modify the dimension of a polynomial.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if in and out point to the same polynomial </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, <a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7">cpl_polynomial_delete()</a>, <a class="el" href="group__cpl__polynomial.html#ga62c3d942b1525bad657cd44ff2e0fbfb">cpl_polynomial_duplicate()</a>, and <a class="el" href="group__cpl__memory.html#ga561426268e5649bd6a44bf14a98ca9e6">cpl_realloc()</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__wlcalib.html#ga33a27df89c2861af93dcb740fce3a192">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad27580d5c9e514cdbcddbd0d4d038e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_polynomial_delete </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a cpl_polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>cpl_polynomial to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>The function deallocates the memory used by the polynomial <em>p</em>. If <em>p</em> is <code>NULL</code>, nothing is done, and no error is set. </p>

<p>References <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>, <a class="el" href="group__cpl__polynomial.html#gafa9242d9e26e39a675f5ca8ddc45f629">cpl_polynomial_copy()</a>, <a class="el" href="group__cpl__polynomial.html#gaf8b13c82eb2b5ae32ba24fd4e3ea4b67">cpl_polynomial_fit_1d_create()</a>, <a class="el" href="group__cpl__polynomial.html#ga1f64ecb14d48a4f5601e54a5914633ca">cpl_polynomial_fit_2d_create()</a>, <a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d()</a>, <a class="el" href="group__cpl__ppm.html#gaccab8c3f2de716c28f89244d4054dd3d">cpl_ppm_match_points()</a>, and <a class="el" href="group__cpl__wlcalib.html#ga33a27df89c2861af93dcb740fce3a192">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2efdebaaf27c73481a42622d45f02b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_derivative </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a first order partial derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to be modified in place </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension to differentiate (zero for first dimension) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a></dd></dl>
<p>The dimension of the polynomial is preserved, even if the operation may cause the polynomial to become independent of the dimension dim of the variable.</p>
<p>The call requires n FLOPs, where n is the number of (non-zero) polynomial coefficients whose power in dimension dim is at least 1.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if dim is negative.</li>
<li>CPL_ERROR_ACCESS_OUT_OF_RANGE if dim exceeds the dimension of self. </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__memory.html#ga561426268e5649bd6a44bf14a98ca9e6">cpl_realloc()</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>.</p>

</div>
</div>
<a class="anchor" id="ga063de2b8047d89e539358ad990eed3f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_dump </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a cpl_polynomial as ASCII to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Input cpl_polynomial to dump </td></tr>
    <tr><td class="paramname">stream</td><td>Output stream, accepts <code>stdout</code> or <code>stderr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a></dd></dl>
<p>Each coefficient is preceded by its integer power(s) and written on a single line. If the polynomial has non-zero coefficients, only those are printed, otherwise the (zero-valued) constant term is printed.</p>
<p>Comment lines start with the hash character.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_FILE_IO if the write operation fails </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900aa54303ad2fb0efc3f8c57c788b342c81">CPL_ERROR_FILE_IO</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>.</p>

</div>
</div>
<a class="anchor" id="ga62c3d942b1525bad657cd44ff2e0fbfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_duplicate </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function duplicates an existing polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The input cpl_polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated cpl_polynomial or NULL on error</dd></dl>
<p>Notice that the returned object is a newly allocated cpl_polynomial that must be deallocated by the caller using <a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7" title="Delete a cpl_polynomial. ">cpl_polynomial_delete()</a>.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, and <a class="el" href="group__cpl__polynomial.html#ga6e95c460a991e29169ff1d079377f334">cpl_polynomial_new()</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>, and <a class="el" href="group__cpl__polynomial.html#gafa9242d9e26e39a675f5ca8ddc45f629">cpl_polynomial_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="gad7022ca32043652bfbd767b197b83bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_eval </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the polynomial at the given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial </td></tr>
    <tr><td class="paramname">x</td><td>Point of evaluation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed value or undefined on error.</dd></dl>
<p>The length of x must be the polynomial dimension.</p>
<p>A polynomial with no non-zero coefficients evaluates as 0.</p>
<p>If the classical evaluation method is used, the computational cost is:</p>
<p>For 1-dimensional polynomials the call requires 2n FLOPs where n+1 is the number of coefficients in p, see also <a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d" title="Evaluate a univariate (1D) polynomial using Horners rule. ">cpl_polynomial_eval_1d()</a>.</p>
<p>For multivariate polynomials the call requires n*(1+dim) + d_1 + d_2 + ... + d_dim FLOPs, where dim is the dimension, n is the number of coefficients in p and d_i is the highest power used in dimension i, i = 1, 2, ..., dim.</p>
<p>If the Horner evaluation method is used the complexity has not been studied yet.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the length of x differs from the dimension of the polynomial </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d">cpl_polynomial_eval_1d()</a>, <a class="el" href="group__cpl__vector.html#gaf2f50a71abb6d452edb3820b967b2022">cpl_vector_get()</a>, and <a class="el" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size()</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>, and <a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0">cpl_vector_fill_polynomial_fit_residual()</a>.</p>

</div>
</div>
<a class="anchor" id="gab002089746a121023e072d2f5d8b057d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_eval_1d </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a univariate (1D) polynomial using Horners rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">x</td><td>The point of evaluation </td></tr>
    <tr><td class="paramname">pd</td><td>Iff pd is non-NULL, the derivative evaluated at x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result or undefined on error.</dd></dl>
<p>A polynomial with no non-zero coefficents evaluates to 0 with a derivative that does likewise.</p>
<p>The result is computed as p_0 + x * ( p_1 + x * ( p_2 + ... x * p_n )) and requires 2n FLOPs where n+1 is the number of coefficients.</p>
<p>If the derivative is requested it is computed using a nested Horner rule. This requires 4n FLOPs in total.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial is not (1D) univariate </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__polynomial.html#gad7022ca32043652bfbd767b197b83bf9">cpl_polynomial_eval()</a>, <a class="el" href="group__cpl__polynomial.html#ga09473199544ac51406f4952dad5b8665">cpl_vector_fill_polynomial()</a>, and <a class="el" href="group__cpl__wlcalib.html#ga33a27df89c2861af93dcb740fce3a192">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a class="anchor" id="gad5a1224f9ecbc2a9984e27ba2a156c9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_eval_1d_diff </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ppa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate p(a) - p(b) using Horners rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">a</td><td>The evaluation point of the minuend </td></tr>
    <tr><td class="paramname">b</td><td>The evaluation point of the subtrahend </td></tr>
    <tr><td class="paramname">ppa</td><td>Iff ppa is not NULL, p(a) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference or undefined on error</dd></dl>
<p>The call requires about 4n FLOPs where n is the number of coefficients in self, which is the same as that required for two separate polynomial evaluations. <a class="el" href="group__cpl__polynomial.html#gad5a1224f9ecbc2a9984e27ba2a156c9b" title="Evaluate p(a) - p(b) using Horners rule. ">cpl_polynomial_eval_1d_diff()</a> is however more accurate.</p>
<p>ppa may be NULL. If it is not, *ppa is set to self(a), which is calculated at no extra cost.</p>
<p>The underlying algorithm is the same as that used in <a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d" title="Evaluate a univariate (1D) polynomial using Horners rule. ">cpl_polynomial_eval_1d()</a> when the derivative is also requested.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial has the wrong dimension </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a class="anchor" id="ga15adba8bfa7344bf4c87c35c77c7ae5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_extract </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapse one dimension of a multi-variate polynomial by composition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The multi-variate polynomial </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension to collapse (zero for first dimension) </td></tr>
    <tr><td class="paramname">other</td><td>The polynomial to replace dimension dim of self </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The collapsed polynomial or NULL on error</dd></dl>
<p>The dimension of the polynomial self must be one greater than that of the other polynomial. Given these two polynomials the dimension dim of self is collapsed by creating a new polynomial from self(x0, x1, ..., x{dim-1}, other(x0, x1, ..., x{dim-1}, x{dim+1}, x{dim+2}, ..., x{n-1}), x{dim+1}, x{dim+2}, ..., x{n-1}).</p>
<p>The created polynomial thus has a dimension which is one less than the polynomial self and which is equal to that of the other polynomial. Collapsing one dimension of a 1D-polynomial is equivalent to evaluating it, which can be done with <a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d" title="Evaluate a univariate (1D) polynomial using Horners rule. ">cpl_polynomial_eval_1d()</a>.</p>
<p>FIXME: The other polynomial must currently have a degree of zero, i.e. it must be a constant.</p>
<p>Currently, the call requires dn + p FLOPs, where d the dimension of the polynomial self, p is the largest power of dimension dim and n the number of (non-zero) coefficients of the polynomial self.</p>
<p>The returned object is a newly allocated cpl_polynomial that must be deallocated by the caller using <a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7" title="Delete a cpl_polynomial. ">cpl_polynomial_delete()</a>.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial is uni-variate.</li>
<li>CPL_ERROR_ILLEGAL_INPUT if dim is negative.</li>
<li>CPL_ERROR_ACCESS_OUT_OF_RANGE if dim exceeds the dimension of self.</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if other has the wrong dimension.</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if other is not of degree 0. </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, <a class="el" href="group__cpl__polynomial.html#ga8914a8d2c87faa2950f7a75c80e313fb">cpl_polynomial_get_coeff()</a>, <a class="el" href="group__cpl__polynomial.html#gacbf283d2c2ad290406f5297c2cdf2bb0">cpl_polynomial_get_degree()</a>, <a class="el" href="group__cpl__polynomial.html#ga6e95c460a991e29169ff1d079377f334">cpl_polynomial_new()</a>, and <a class="el" href="group__cpl__polynomial.html#gab9bbab67ece20c05a3ad20f2c3fef203">cpl_polynomial_set_coeff()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa4cdbbf2a50f568d9768cf793b53b187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_fit </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_matrix *&#160;</td>
          <td class="paramname"><em>samppos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_boolean *&#160;</td>
          <td class="paramname"><em>sampsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitsigm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_boolean&#160;</td>
          <td class="paramname"><em>dimdeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>mindeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>maxdeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a polynomial to a set of samples in a least squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Polynomial of dimension d to hold the coefficients </td></tr>
    <tr><td class="paramname">samppos</td><td>Matrix of p sample positions, with d rows and p columns </td></tr>
    <tr><td class="paramname">sampsym</td><td>NULL, or d booleans, true iff the sampling is symmetric </td></tr>
    <tr><td class="paramname">fitvals</td><td>Vector of the p values to fit </td></tr>
    <tr><td class="paramname">fitsigm</td><td>Uncertainties of the sampled values, or NULL for all ones </td></tr>
    <tr><td class="paramname">dimdeg</td><td>True iff there is a fitting degree per dimension </td></tr>
    <tr><td class="paramname">mindeg</td><td>Pointer to 1 or d minimum fitting degree(s), or NULL </td></tr>
    <tr><td class="paramname">maxdeg</td><td>Pointer to 1 or d maximum fitting degree(s), at least mindeg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE on success, else the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently only uni- and bi-variate polynomials are supported, fitsigm must be NULL. For all but uni-variate polynomials mindeg must be zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0" title="Compute the residual of a polynomial fit. ">cpl_vector_fill_polynomial_fit_residual()</a></dd></dl>
<p>Any pre-set non-zero coefficients in self are overwritten or reset by the fit.</p>
<p>For 1D-polynomials N = 1 + maxdeg - mindeg coefficients are fitted.</p>
<p>For multi-variate polynomials the fit depends on dimdeg:</p>
<p>If dimdeg is false, an n-degree coefficient is fitted iff mindeg &lt;= n &lt;= maxdeg. For a 2D-polynomial this means that N * (N + 1) / 2 coefficients are fitted.</p>
<p>If dimdeg is true, nci = 1 + maxdeg[i] + mindeg[i] coefficients are fitted for dimension i, i.e. for a 2D-polynomial N = nc1 * nc2 coefficients are fitted.</p>
<p>The number of distinct samples should exceed the number of coefficients to fit. The number of distinct samples may also equal the number of coefficients to fit, but in this case the fit has another meaning (any non-zero residual is due to rounding errors, not a fitting error). It is an error to try to fit more coefficients than there are distinct samples.</p>
<p>If the relative uncertainties of the sampled values are known, they may be passed via fitsigm. NULL means that all uncertainties equals one.</p>
<p>sampsym is ignored if mindeg is nonzero, otherwise the caller may use sampsym to indicate an a priori knowledge that the sampling positions are symmetric. NULL indicates no knowledge of such symmetry. sampsym[i] may be set to true iff the sampling is symmetric around u_i, where u_i is the mean of the sampling positions in dimension i.</p>
<p>In 1D this implies that the sampling points as pairs average u_0 (with an odd number of samples one sample must equal u_0). E.g. both x = (1, 2, 4, 6, 7) and x = (1, 6, 4, 2, 7) have sampling symmetry, while x = (1, 2, 4, 6) does not.</p>
<p>In 2D this implies that the sampling points are symmetric in the 2D-plane. For the first dimension sampling symmetry means that the sampling is line- symmetric around y = u_1, while for the second dimension, sampling symmetry implies line-symmetry around x = u_2. Point symmetry around (x,y) = (u_1, u_2) means that both sampsym[0] and sampsym[1] may be set to true.</p>
<p>Knowledge of symmetric sampling allows the fit to be both faster and eliminates certain round-off errors.</p>
<p>For higher order fitting the fitting problem known as "Runge's phenomenon" is minimized using the socalled "Chebyshev nodes" as sampling points. For Chebyshev nodes sampsym can be set to CPL_TRUE.</p>
<p>Warning: An increase in the polynomial degree will normally reduce the fitting error. However, due to rounding errors and the limited accuracy of the solver of the normal equations, an increase in the polynomial degree may at some point cause the fitting error to <em>increase</em>. In some cases this happens with an increase of the polynomial degree from 8 to 9.</p>
<p>The fit is done in the following steps: 1) If mindeg is zero, the sampling positions are first transformed into Xhat_i = X_i - mean(X_i), i=1, .., dimension. 2) The Vandermonde matrix is formed from Xhat. 3) The normal equations of the Vandermonde matrix is solved. 4) If mindeg is zero, the resulting polynomial in Xhat is transformed back to X.</p>
<p>For a univariate (1D) fit the call requires 6MN + N^3/3 + 7/2N^2 + O(M) FLOPs where M is the number of data points and where N is the number of polynomial coefficients to fit, N = 1 + maxdeg - mindeg.</p>
<p>For a bivariate fit the call requires MN^2 + N^3/3 + O(MN) FLOPs where M is the number of data points and where N is the number of polynomial coefficients to fit.</p>
<p>Examples of usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cpl_polynomial  * fit1d     = cpl_polynomial_new(1);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cpl_matrix      * samppos1d = my_sampling_points_1d(); // 1-row matrix</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cpl_vector      * fitvals   = my_sampling_values();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;const cpl_boolean sampsym   = CPL_TRUE;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;const int         maxdeg1d  = 4; // Fit 5 coefficients</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;cpl_error_code    error1d</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    = cpl_polynomial_fit(fit1d, samppos1d, &amp;sampsym, fitvals, NULL,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;                         CPL_FALSE, NULL, &amp;maxdeg1d);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cpl_polynomial  * fit2d      = cpl_polynomial_new(2);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cpl_matrix      * samppos2d  = my_sampling_points_2d(); // 2-row matrix</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cpl_vector      * fitvals    = my_sampling_values();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;const int         maxdeg2d[] = {2, 1}; // Fit 6 coefficients</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;cpl_error_code    error2d</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    = cpl_polynomial_fit(fit2d, samppos2d, NULL, fitvals, NULL, CPL_FALSE,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;                         NULL, maxdeg2d);</div>
</div><!-- fragment --><p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if a mindeg value is negative, or if a maxdeg value is less than the corresponding mindeg value.</li>
<li>CPL_ERROR_DATA_NOT_FOUND if the number of columns in samppos is less than the number of coefficients to be determined.</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if samppos, fitvals or fitsigm have incompatible sizes, or if samppos, self or sampsym have incompatible sizes.</li>
<li>CPL_ERROR_SINGULAR_MATRIX if samppos contains too few distinct values</li>
<li>CPL_ERROR_DIVISION_BY_ZERO if an element in fitsigm is zero</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if the polynomial dimension exceeds two, or if there is a non-zero value in the mindeg array. </li>
</ul>

<p>References <a class="el" href="group__cpl__bivector.html#ga1ea86fc1994ea6175a7da6db8966db86">cpl_bivector_unwrap_vectors()</a>, <a class="el" href="group__cpl__bivector.html#ga8ae96fc17c12f7140ac23448874b72ff">cpl_bivector_wrap_vectors()</a>, <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__matrix.html#gac3ae0a639b51b6e2a7c85046ad3f4b7f">cpl_matrix_get_data()</a>, <a class="el" href="group__cpl__matrix.html#ga4bade56f31c3e0f69ca513a557c1d4fd">cpl_matrix_get_ncol()</a>, <a class="el" href="group__cpl__matrix.html#gaba2be6537f0aacb0dfea437f186627c9">cpl_matrix_get_nrow()</a>, <a class="el" href="group__cpl__polynomial.html#ga4436f9900625ba6f19f189f5b0ee99d2">cpl_polynomial_get_dimension()</a>, <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>, <a class="el" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size()</a>, <a class="el" href="group__cpl__vector.html#ga3d022e443df6e51ae2c005285d978957">cpl_vector_unwrap()</a>, and <a class="el" href="group__cpl__vector.html#ga1f52028a78be1cab17567cf15c483fcc">cpl_vector_wrap()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8b13c82eb2b5ae32ba24fd4e3ea4b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_fit_1d_create </td>
          <td>(</td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>x_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a 1D-polynomial to a 1D-signal in a least squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_pos</td><td>Vector of positions of the signal to fit. </td></tr>
    <tr><td class="paramname">values</td><td>Vector of values of the signal to fit. </td></tr>
    <tr><td class="paramname">degree</td><td>Non-negative polynomial degree. </td></tr>
    <tr><td class="paramname">mse</td><td>Iff mse is not null, the mean squared error on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted polynomial or NULL on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense. ">cpl_polynomial_fit()</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Replace this call with <a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense. ">cpl_polynomial_fit()</a> and optionally <a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0" title="Compute the residual of a polynomial fit. ">cpl_vector_fill_polynomial_fit_residual()</a>.</dd></dl>

<p>References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7">cpl_polynomial_delete()</a>, and <a class="el" href="group__cpl__polynomial.html#ga6e95c460a991e29169ff1d079377f334">cpl_polynomial_new()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f64ecb14d48a4f5601e54a5914633ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_fit_2d_create </td>
          <td>(</td>
          <td class="paramtype">cpl_bivector *&#160;</td>
          <td class="paramname"><em>xy_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_vector *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a 2D-polynomial to a 2D-surface in a least squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xy_pos</td><td>Bivector positions of the surface to fit. </td></tr>
    <tr><td class="paramname">values</td><td>Vector of values of the surface to fit. </td></tr>
    <tr><td class="paramname">degree</td><td>Non-negative polynomial degree. </td></tr>
    <tr><td class="paramname">mse</td><td>Iff mse is not null, the mean squared error on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted polynomial or NULL on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense. ">cpl_polynomial_fit()</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Replace this call with <a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense. ">cpl_polynomial_fit()</a> and optionally <a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0" title="Compute the residual of a polynomial fit. ">cpl_vector_fill_polynomial_fit_residual()</a>.</dd></dl>

<p>References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7">cpl_polynomial_delete()</a>, and <a class="el" href="group__cpl__polynomial.html#ga6e95c460a991e29169ff1d079377f334">cpl_polynomial_new()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8914a8d2c87faa2950f7a75c80e313fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_get_coeff </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>pows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a coefficient of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input polynomial </td></tr>
    <tr><td class="paramname">pows</td><td>the powers of the different variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coefficient or undefined on error</dd></dl>
<p>The array pows must have the size of the polynomial dimension and have non-negative elements.</p>
<p>It is allowed to specify a (set of) power(s) for which no coefficient has previously been set. In this case the function returns zero.</p>
<p>Example of usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const cpl_size power       = 3;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;double         coefficient = cpl_polynomial_get_coeff(poly1d, &amp;power);</div>
</div><!-- fragment --><p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if pows contains negative values </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">cpl_polynomial_add()</a>, <a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract()</a>, <a class="el" href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">cpl_polynomial_multiply_scalar()</a>, <a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d()</a>, and <a class="el" href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">cpl_polynomial_subtract()</a>.</p>

</div>
</div>
<a class="anchor" id="gacbf283d2c2ad290406f5297c2cdf2bb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_polynomial_get_degree </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The degree of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The degree or negative on error</dd></dl>
<p>The degree is the highest sum of exponents (with a non-zero coefficient).</p>
<p>If there are no non-zero coefficients the degree is zero.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">cpl_polynomial_add()</a>, <a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract()</a>, <a class="el" href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">cpl_polynomial_multiply_scalar()</a>, <a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d()</a>, <a class="el" href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">cpl_polynomial_subtract()</a>, and <a class="el" href="group__cpl__wlcalib.html#ga33a27df89c2861af93dcb740fce3a192">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4436f9900625ba6f19f189f5b0ee99d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_polynomial_get_dimension </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The dimension of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dimension or negative on error</dd></dl>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>, <a class="el" href="group__cpl__image.html#ga3e46978badb07da8a75caf267452bf5d">cpl_image_fill_polynomial()</a>, <a class="el" href="group__cpl__image.html#ga34b80ed421f88c5bdad3f0127d251975">cpl_image_warp_polynomial()</a>, <a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">cpl_polynomial_add()</a>, <a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">cpl_polynomial_fit()</a>, <a class="el" href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">cpl_polynomial_multiply_scalar()</a>, <a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d()</a>, <a class="el" href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">cpl_polynomial_subtract()</a>, <a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0">cpl_vector_fill_polynomial_fit_residual()</a>, and <a class="el" href="group__cpl__wlcalib.html#ga33a27df89c2861af93dcb740fce3a192">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_multiply_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a polynomial with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to hold the result </td></tr>
    <tr><td class="paramname">other</td><td>The polynomial to scale, may equal self </td></tr>
    <tr><td class="paramname">factor</td><td>The factor to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant CPL error code</dd></dl>
<p>Possible CPL error code set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if the dimension is not 1 (FIXME) </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__polynomial.html#ga8914a8d2c87faa2950f7a75c80e313fb">cpl_polynomial_get_coeff()</a>, <a class="el" href="group__cpl__polynomial.html#gacbf283d2c2ad290406f5297c2cdf2bb0">cpl_polynomial_get_degree()</a>, <a class="el" href="group__cpl__polynomial.html#ga4436f9900625ba6f19f189f5b0ee99d2">cpl_polynomial_get_dimension()</a>, and <a class="el" href="group__cpl__polynomial.html#gab9bbab67ece20c05a3ad20f2c3fef203">cpl_polynomial_set_coeff()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e95c460a991e29169ff1d079377f334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new cpl_polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The positive polynomial dimension (number of variables) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 newly allocated cpl_polynomial, or NULL on error</dd></dl>
<p>The returned object must be deallocated using <a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7" title="Delete a cpl_polynomial. ">cpl_polynomial_delete()</a>.</p>
<p>A newly created polynomial has degree 0 and evaluates as 0.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_ILLEGAL_INPUT if dim is negative or zero </li>
</ul>

<p>References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gafb123879d8683c6d63681f433dc19bd0">cpl_ensure</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__polynomial.html#ga62c3d942b1525bad657cd44ff2e0fbfb">cpl_polynomial_duplicate()</a>, <a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract()</a>, <a class="el" href="group__cpl__polynomial.html#gaf8b13c82eb2b5ae32ba24fd4e3ea4b67">cpl_polynomial_fit_1d_create()</a>, <a class="el" href="group__cpl__polynomial.html#ga1f64ecb14d48a4f5601e54a5914633ca">cpl_polynomial_fit_2d_create()</a>, <a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d()</a>, <a class="el" href="group__cpl__ppm.html#gaccab8c3f2de716c28f89244d4054dd3d">cpl_ppm_match_points()</a>, and <a class="el" href="group__cpl__wlcalib.html#ga33a27df89c2861af93dcb740fce3a192">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a class="anchor" id="gab9bbab67ece20c05a3ad20f2c3fef203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_set_coeff </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>pows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a coefficient of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input polynomial </td></tr>
    <tr><td class="paramname">pows</td><td>the powers of the different variables </td></tr>
    <tr><td class="paramname">c</td><td>the coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a></dd></dl>
<p>The array pows must have the size of the polynomial dimension and have non-negative elements.</p>
<p>If the coefficient is already there, it is overwritten, if not, a new coefficient is added to the polynomial. This may cause the degree of the polynomial to be increased.</p>
<p>Setting the coefficient of x1^4 * x3^2 in the 4-dimensional polynomial poly4d to 12.3 would be performed by:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const cpl_size pows[] = {4, 0, 2, 0};</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cpl_error_code error  = cpl_polynomial_set_coeff(poly4d, pows, 12.3);</div>
</div><!-- fragment --><p>Setting the coefficient of x^3 in the 1-dimensional polynomial poly1d to 12.3 would be performed by: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const cpl_size power = 3;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cpl_error_code error = cpl_polynomial_set_coeff(poly1d, &amp;power, 12.3);</div>
</div><!-- fragment --><p>For efficiency reasons the coefficients of a 1D-polynomial are best inserted with that of the highest power first.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if pows contains negative values </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, and <a class="el" href="group__cpl__memory.html#ga561426268e5649bd6a44bf14a98ca9e6">cpl_realloc()</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">cpl_polynomial_add()</a>, <a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract()</a>, <a class="el" href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">cpl_polynomial_multiply_scalar()</a>, <a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d()</a>, and <a class="el" href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">cpl_polynomial_subtract()</a>.</p>

</div>
</div>
<a class="anchor" id="gad445a939e63d62bc91455b5ef7924559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_shift_1d </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify p, p(x0, x1, ..., xi, ...) := (x0, x1, ..., xi+u, ...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to be modified in place </td></tr>
    <tr><td class="paramname">i</td><td>The dimension to shift (0 for first) </td></tr>
    <tr><td class="paramname">u</td><td>The shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, only dimensions 1 and 2 are supported</dd></dl>
<p>Shifting the polynomial p(x) = x^n with u = 1 will generate the binomial coefficients for n.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if i is negative</li>
<li>CPL_ERROR_ACCESS_OUT_OF_RANGE if i exceeds the dimension of p</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if the polynomial has a dimension larger than 2 </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__polynomial.html#gaad27580d5c9e514cdbcddbd0d4d038e7">cpl_polynomial_delete()</a>, <a class="el" href="group__cpl__polynomial.html#ga8914a8d2c87faa2950f7a75c80e313fb">cpl_polynomial_get_coeff()</a>, <a class="el" href="group__cpl__polynomial.html#gacbf283d2c2ad290406f5297c2cdf2bb0">cpl_polynomial_get_degree()</a>, <a class="el" href="group__cpl__polynomial.html#ga4436f9900625ba6f19f189f5b0ee99d2">cpl_polynomial_get_dimension()</a>, <a class="el" href="group__cpl__polynomial.html#ga6e95c460a991e29169ff1d079377f334">cpl_polynomial_new()</a>, and <a class="el" href="group__cpl__polynomial.html#gab9bbab67ece20c05a3ad20f2c3fef203">cpl_polynomial_set_coeff()</a>.</p>

<p>Referenced by <a class="el" href="group__cpl__wlcalib.html#ga33a27df89c2861af93dcb740fce3a192">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a44da11383b2d44cd23cc0708611530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_solve_1d </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>mul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A real solution to p(x) = 0 using Newton-Raphsons method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">x0</td><td>First guess of the solution </td></tr>
    <tr><td class="paramname">px</td><td>The solution, on error see below </td></tr>
    <tr><td class="paramname">mul</td><td>The root multiplicity (or 1 if unknown) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a></dd></dl>
<p>Even if a real solution exists, it may not be found if the first guess is too far from the solution. But a solution is guaranteed to be found if all roots of p are real. If the constant term is zero, the solution 0 will be returned regardless of the first guess.</p>
<p>No solution is found when the iterative process stops because: 1) It can not proceed because p`(x) = 0 (CPL_ERROR_DIVISION_BY_ZERO). 2) Only a finite number of iterations are allowed (CPL_ERROR_CONTINUE). Both cases may be due to lack of a real solution or a bad first guess. In these two cases *px is set to the value where the error occurred. In case of other errors *px is unmodified.</p>
<p>The accuracy and robustness deteriorates with increasing multiplicity of the solution. This is also the case with numerical multiplicity, i.e. when multiple solutions are located close together.</p>
<p>mul is assumed to be the multiplicity of the solution. Knowledge of the root multiplicity often improves the robustness and accuracy. If there is no knowledge of the root multiplicity mul should be 1. Setting mul to a too high value should be avoided.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial has the wrong dimension</li>
<li>CPL_ERROR_ILLEGAL_INPUT if the multiplicity is non-positive</li>
<li>CPL_ERROR_DIVISION_BY_ZERO if a division by zero occurs</li>
<li>CPL_ERROR_CONTINUE if the algorithm does not converge </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>.</p>

</div>
</div>
<a class="anchor" id="ga457ef230f6dcc5ce6517386ea832aaa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_subtract </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two polynomials of the same dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to hold the result </td></tr>
    <tr><td class="paramname">first</td><td>The polynomial to subtract from </td></tr>
    <tr><td class="paramname">second</td><td>The polynomial to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant CPL error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>self may be passed also as first and/or second</dd></dl>
<p>Possible CPL error code set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the polynomials do not have identical dimensions</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if the dimension is not 1 (FIXME) </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__polynomial.html#ga8914a8d2c87faa2950f7a75c80e313fb">cpl_polynomial_get_coeff()</a>, <a class="el" href="group__cpl__polynomial.html#gacbf283d2c2ad290406f5297c2cdf2bb0">cpl_polynomial_get_degree()</a>, <a class="el" href="group__cpl__polynomial.html#ga4436f9900625ba6f19f189f5b0ee99d2">cpl_polynomial_get_dimension()</a>, and <a class="el" href="group__cpl__polynomial.html#gab9bbab67ece20c05a3ad20f2c3fef203">cpl_polynomial_set_coeff()</a>.</p>

</div>
</div>
<a class="anchor" id="ga09473199544ac51406f4952dad5b8665"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_vector_fill_polynomial </td>
          <td>(</td>
          <td class="paramtype">cpl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 1D-polynomial on equidistant points using Horners rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Preallocated vector to contain the result </td></tr>
    <tr><td class="paramname">p</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">x0</td><td>The first point of evaluation </td></tr>
    <tr><td class="paramname">d</td><td>The increment between points of evaluation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__vector.html#ga72cfd50426a679a370e154f54a5fed4d" title="Fill a cpl_vector. ">cpl_vector_fill</a></dd></dl>
<p>The evaluation points are x_i = x0 + i * d, i=0, 1, ..., n-1, where n is the length of the vector.</p>
<p>If d is zero it is preferable to simply use cpl_vector_fill(v, cpl_polynomial_eval_1d(p, x0, NULL)).</p>
<p>The call requires about 2nm FLOPs, where m+1 is the number of coefficients in p.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial has the wrong dimension </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d">cpl_polynomial_eval_1d()</a>, <a class="el" href="group__cpl__vector.html#gaca37a188555aff6e2379199e7fae49be">cpl_vector_get_data()</a>, and <a class="el" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d23d4b42c4d98bb6e50e53e67350aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_vector_fill_polynomial_fit_residual </td>
          <td>(</td>
          <td class="paramtype">cpl_vector *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitsigm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_matrix *&#160;</td>
          <td class="paramname"><em>samppos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rechisq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the residual of a polynomial fit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Vector to hold the fitting residuals, fitvals may be used </td></tr>
    <tr><td class="paramname">fitvals</td><td>Vector of the p fitted values </td></tr>
    <tr><td class="paramname">fitsigm</td><td>Uncertainties of the sampled values or NULL for a uniform uncertainty </td></tr>
    <tr><td class="paramname">fit</td><td>The fitted polynomial </td></tr>
    <tr><td class="paramname">samppos</td><td>Matrix of p sample positions, with d rows and p columns </td></tr>
    <tr><td class="paramname">rechisq</td><td>If non-NULL, the reduced chi square of the fit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE on success, else the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If necessary, self is resized to the length of fitvals. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense. ">cpl_polynomial_fit()</a></dd></dl>
<p>It is allowed to pass the same vector as both fitvals and as self, in which case fitvals is overwritten with the residuals.</p>
<p>If the relative uncertainties of the sampled values are known, they may be passed via fitsigm. NULL means that all uncertainties equal one. The uncertainties are taken into account when computing the reduced chi square value.</p>
<p>If rechisq is non-NULL, the reduced chi square of the fit is computed as well.</p>
<p>The mean square error, which was computed directly by the former CPL functions <a class="el" href="group__cpl__polynomial.html#gaf8b13c82eb2b5ae32ba24fd4e3ea4b67" title="Fit a 1D-polynomial to a 1D-signal in a least squares sense. ">cpl_polynomial_fit_1d_create()</a> and <a class="el" href="group__cpl__polynomial.html#ga1f64ecb14d48a4f5601e54a5914633ca" title="Fit a 2D-polynomial to a 2D-surface in a least squares sense. ">cpl_polynomial_fit_2d_create()</a> can be computed from the fitting residual like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const double mse = cpl_vector_product(fitresidual, fitresidual)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                 / cpl_vector_get_size(fitresidual);</div>
</div><!-- fragment --><p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes. ">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer (other than fitsigm) is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if samppos, fitvals, fitsigm or fit have incompatible sizes</li>
<li>CPL_ERROR_DIVISION_BY_ZERO if an element in fitsigm is zero</li>
<li>CPL_ERROR_DATA_NOT_FOUND if the number of columns in samppos is less than the number of coefficients in the fitted polynomial. </li>
</ul>

<p>References <a class="el" href="group__cpl__error.html#gaf18e95fbc6fc2cfde2a2cc8a0920b12d">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a5b82c7780a2a8a79dfafcac70717b830">CPL_ERROR_DATA_NOT_FOUND</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900afbc03558f2ea2b19e48a2af5901d19d1">CPL_ERROR_DIVISION_BY_ZERO</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__matrix.html#ga49f69f09c0f6a8610318aeb90beee97c">cpl_matrix_get()</a>, <a class="el" href="group__cpl__matrix.html#ga4bade56f31c3e0f69ca513a557c1d4fd">cpl_matrix_get_ncol()</a>, <a class="el" href="group__cpl__matrix.html#gaba2be6537f0aacb0dfea437f186627c9">cpl_matrix_get_nrow()</a>, <a class="el" href="group__cpl__polynomial.html#gad7022ca32043652bfbd767b197b83bf9">cpl_polynomial_eval()</a>, <a class="el" href="group__cpl__polynomial.html#ga4436f9900625ba6f19f189f5b0ee99d2">cpl_polynomial_get_dimension()</a>, <a class="el" href="group__cpl__vector.html#gaf563c19d309c5b60d148a84cb156c2cf">cpl_vector_delete()</a>, <a class="el" href="group__cpl__vector.html#gaf2f50a71abb6d452edb3820b967b2022">cpl_vector_get()</a>, <a class="el" href="group__cpl__vector.html#gaca37a188555aff6e2379199e7fae49be">cpl_vector_get_data()</a>, <a class="el" href="group__cpl__vector.html#ga991ded30622122c78bb34191f7c7a7c6">cpl_vector_get_data_const()</a>, <a class="el" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size()</a>, <a class="el" href="group__cpl__vector.html#ga0a0d8b61b19cd1d3668525a3f2d55e72">cpl_vector_new()</a>, <a class="el" href="group__cpl__vector.html#ga09ea2aa6ee2fe7350dacb9d4d5b0d9f6">cpl_vector_product()</a>, and <a class="el" href="group__cpl__vector.html#ga82def4430dfa77393ae974bbc915d360">cpl_vector_set_size()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
